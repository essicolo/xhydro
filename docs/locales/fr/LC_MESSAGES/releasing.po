# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Thomas-Charles Fortier Filion
# This file is distributed under the same license as the xHydro package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: xHydro 0.3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-11 16:20-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: fr\n"
"Language-Team: fr <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.14.0\n"

#: ../../releasing.rst:3
msgid "Releasing"
msgstr ""

#: ../../releasing.rst:6
msgid "Deployment"
msgstr ""

#: ../../releasing.rst:8
msgid ""
"A reminder for the **maintainers** on how to deploy. This section is only"
" relevant when producing a new point release for the package."
msgstr ""

#: ../../releasing.rst:12
msgid ""
"It is important to be aware that any changes to files found within the "
"``src/xhydro`` folder (with the exception of ``src/xhydro/__init__.py``) "
"will trigger the ``bump-version.yml`` workflow. Be careful not to commit "
"changes to files in this folder when preparing a new release."
msgstr ""

#: ../../releasing.rst:14
msgid "Create a new branch from `main` (e.g. `release-0.2.0`)."
msgstr ""

#: ../../releasing.rst:15
msgid ""
"Update the `CHANGELOG.rst` file to change the `Unreleased` section to the"
" current date."
msgstr ""

#: ../../releasing.rst:16
msgid ""
"Bump the version in your branch to the next version (e.g. `v0.1.0 -> "
"v0.2.0`):"
msgstr ""

#: ../../releasing.rst:24
msgid "Create a pull request from your branch to `main`."
msgstr ""

#: ../../releasing.rst:25
msgid ""
"Once the pull request is merged, create a new release on GitHub. On the "
"`main` branch, run:"
msgstr ""

#: ../../releasing.rst:32
msgid ""
"This will trigger a GitHub workflow to build the package and upload it to"
" TestPyPI. At the same time, the GitHub workflow will create a draft "
"release on GitHub. Assuming that the workflow passes, the final release "
"can then be published on GitHub by finalizing the draft release."
msgstr ""

#: ../../releasing.rst:34
msgid "To generate the release notes, run:"
msgstr ""

#: ../../releasing.rst:42
msgid ""
"This will print the release notes (taken from the `HISTORY.rst` file) to "
"your python console. Copy and paste them into the GitHub release "
"description, keeping only the changes for the current version."
msgstr ""

#: ../../releasing.rst:44
msgid ""
"Once the release is published, the `publish-pypi.yml` workflow will go "
"into an `awaiting approval` mode on Github Actions. Only authorized users"
" may approve this workflow (notifications will be sent) to trigger the "
"upload to PyPI."
msgstr ""

#: ../../releasing.rst:48
msgid ""
"Uploads to PyPI can **never** be overwritten. If you make a mistake, you "
"will need to bump the version and re-release the package. If the package "
"uploaded to PyPI is broken, you should modify the GitHub release to mark "
"the package as broken, as well as yank the package (mark the version "
"\"broken\") on PyPI."
msgstr ""

#: ../../releasing.rst:51
msgid "Packaging"
msgstr ""

#: ../../releasing.rst:53
msgid ""
"When a new version has been minted (features have been successfully "
"integrated test coverage and stability is adequate), maintainers should "
"update the pip-installable package (wheel and source release) on PyPI as "
"well as the binary on conda-forge."
msgstr ""

#: ../../releasing.rst:56
msgid "The simple approach"
msgstr ""

#: ../../releasing.rst:58
msgid ""
"The simplest approach to packaging for general support (pip wheels) "
"requires that `flit` be installed:"
msgstr ""

#: ../../releasing.rst:64
msgid ""
"From the command line on your Linux distribution, simply run the "
"following from the clone's main dev branch:"
msgstr ""

#: ../../releasing.rst:74
msgid ""
"The new version based off of the version checked out will now be "
"available via `pip` (`pip install xhydro`)."
msgstr ""

#: ../../releasing.rst:77
msgid "Releasing on conda-forge"
msgstr ""

#: ../../releasing.rst:80
msgid "Initial Release"
msgstr ""

#: ../../releasing.rst:82
msgid ""
"Before preparing an initial release on conda-forge, we *strongly* suggest"
" consulting the following links:"
msgstr ""

#: ../../releasing.rst:83
msgid "https://conda-forge.org/docs/maintainer/adding_pkgs.html"
msgstr ""

#: ../../releasing.rst:84
msgid "https://github.com/conda-forge/staged-recipes"
msgstr ""

#: ../../releasing.rst:86
msgid ""
"In order to create a new conda build recipe, to be used when proposing "
"packages to the conda-forge repository, we strongly suggest using the "
"`grayskull` tool::"
msgstr ""

#: ../../releasing.rst:93
msgid ""
"For more information on `grayskull`, please see the following link: "
"https://github.com/conda/grayskull"
msgstr ""

#: ../../releasing.rst:95
msgid ""
"Before updating the main conda-forge recipe, we echo the conda-forge "
"documentation and *strongly* suggest performing the following checks:"
msgstr ""

#: ../../releasing.rst:96
msgid ""
"Ensure that dependencies and dependency versions correspond with those of"
" the tagged version, with open or pinned versions for the `host` "
"requirements."
msgstr ""

#: ../../releasing.rst:97
msgid ""
"If possible, configure tests within the conda-forge build CI (e.g. "
"`imports: xhydro`, `commands: pytest xhydro`)."
msgstr ""

#: ../../releasing.rst:100
msgid "Subsequent releases"
msgstr ""

#: ../../releasing.rst:102
msgid ""
"If the conda-forge feedstock recipe is built from PyPI, then when a new "
"release is published on PyPI, `regro-cf-autotick-bot` will open Pull "
"Requests automatically on the conda-forge feedstock. It is up to the "
"conda-forge feedstock maintainers to verify that the package is building "
"properly before merging the Pull Request to the main branch."
msgstr ""

#: ../../releasing.rst:105
msgid "Building sources for wide support with `manylinux` image"
msgstr ""

#: ../../releasing.rst:108
msgid ""
"This section is for building source files that link to or provide links "
"to C/C++ dependencies. It is not necessary to perform the following when "
"building pure Python packages."
msgstr ""

#: ../../releasing.rst:111
msgid ""
"In order to do ensure best compatibility across architectures, we suggest"
" building wheels using the `PyPA`'s `manylinux` docker images (at time of"
" writing, we endorse using `manylinux_2_24_x86_64`)."
msgstr ""

#: ../../releasing.rst:113
msgid "With `docker` installed and running, begin by pulling the image:"
msgstr ""

#: ../../releasing.rst:119
msgid ""
"From the xHydro source folder we can enter into the docker container, "
"providing access to the `src/xhydro` source files by linking them to the "
"running image:"
msgstr ""

#: ../../releasing.rst:125
msgid ""
"Finally, to build the wheel, we run it against the provided Python3.9 "
"binary:"
msgstr ""

#: ../../releasing.rst:131
msgid ""
"This will then place two files in `xhydro/dist/` (\"xhydro-1.2.3-py3"
"-none-any.whl\" and \"xHydro-1.2.3.tar.gz\"). We can now leave our docker"
" container (`exit`) and continue with uploading the files to PyPI:"
msgstr ""
